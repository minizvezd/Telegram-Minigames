<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Сапёр</title>
  <style>
    body {
      margin: 0; 
      padding: 0;
      background: #ccc;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    header {
      width: 100%;
      background: #4CAF50;
      color: #fff;
      text-align: center;
      padding: 10px;
      position: relative;
    }
    .back-button {
      position: absolute;
      left: 10px;
      top: 10px;
      text-decoration: none;
      background: #333;
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 14px;
    }
    .back-button:hover {
      background: #555;
    }
    h1 {
      margin: 0;
      font-size: 20px;
    }
    #info {
      margin: 10px;
      font-size: 18px;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(8, 40px);
      grid-gap: 3px;
      margin-bottom: 20px;
    }
    .cell {
      width: 40px;
      height: 40px;
      background: #bbb;
      color: #000;
      font-weight: bold;
      font-size: 18px;
      border: 1px solid #999;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      user-select: none;
      border-radius: 3px;
    }
    .cell.open {
      background: #eee;
      cursor: default;
    }
    .cell.flag {
      background: #bbb url("data:image/svg+xml,%3Csvg fill='%23f00' viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M80 32v448h32V288h272c17.7 0 32-14.3 32-32v-49c0-10.6-5.2-20.6-14-26.7L276.5 112l125.5-68.3c8.7-5 14-14.1 14-24.1V-30c0-17.7-14.3-32-32-32H112c-17.7 0-32 14.3-32 32v64z'/%3E%3C/svg%3E") center center no-repeat;
      background-size: 24px;
    }
    .cell.mine {
      background: #f66;
      color: #fff;
    }
  </style>
</head>
<body>
  <header>
    <a class="back-button" href="index.html">Назад</a>
    <h1>Сапёр 8×8</h1>
  </header>
  <div id="info">Осталось мин: <span id="minesCount">10</span></div>
  <div id="board"></div>

  <script>
    const boardElem = document.getElementById("board");
    const minesCountElem = document.getElementById("minesCount");
    const size = 8;
    const mineTotal = 10;

    let board = [];
    let cellsLeft = size*size; // сколько ячеек закрыто

    function initBoard(){
      board = [];
      for(let r=0; r<size; r++){
        let row = [];
        for(let c=0; c<size; c++){
          row.push({
            mine: false,
            open: false,
            flag: false,
            adjacent: 0
          });
        }
        board.push(row);
      }
      // Расставляем мины
      let placed = 0;
      while(placed < mineTotal){
        let rr = Math.floor(Math.random()*size);
        let cc = Math.floor(Math.random()*size);
        if(!board[rr][cc].mine){
          board[rr][cc].mine = true;
          placed++;
        }
      }
      // Считаем соседей
      for(let r=0; r<size; r++){
        for(let c=0; c<size; c++){
          if(!board[r][c].mine){
            board[r][c].adjacent = countMines(r,c);
          }
        }
      }
      cellsLeft = size*size;
      updateMinesCount();
    }

    function countMines(r,c){
      let count = 0;
      for(let rr=-1; rr<=1; rr++){
        for(let cc=-1; cc<=1; cc++){
          let nr = r+rr;
          let nc = c+cc;
          if(nr>=0 && nr<size && nc>=0 && nc<size && board[nr][nc].mine){
            count++;
          }
        }
      }
      return count;
    }

    function drawBoard(){
      boardElem.innerHTML = "";
      for(let r=0; r<size; r++){
        for(let c=0; c<size; c++){
          const cellDiv = document.createElement("div");
          cellDiv.classList.add("cell");
          cellDiv.dataset.r = r;
          cellDiv.dataset.c = c;

          let cell = board[r][c];
          if(cell.open){
            cellDiv.classList.add("open");
            if(cell.mine){
              cellDiv.classList.add("mine");
              cellDiv.textContent = "X";
            } else if(cell.adjacent > 0){
              cellDiv.textContent = cell.adjacent;
            }
          } else if(cell.flag){
            cellDiv.classList.add("flag");
          }

          boardElem.appendChild(cellDiv);
        }
      }
    }

    boardElem.addEventListener("click", e => {
      const target = e.target;
      if(!target.classList.contains("cell")) return;
      let r = +target.dataset.r;
      let c = +target.dataset.c;
      openCell(r,c);
      drawBoard();
    });

    boardElem.addEventListener("contextmenu", e => {
      e.preventDefault();
      const target = e.target;
      if(!target.classList.contains("cell")) return;
      let r = +target.dataset.r;
      let c = +target.dataset.c;
      toggleFlag(r,c);
      drawBoard();
    });

    function openCell(r,c){
      let cell = board[r][c];
      if(cell.open || cell.flag) return;
      cell.open = true;
      cellsLeft--;

      if(cell.mine){
        alert("Мина! Игра окончена.");
        revealAll();
        return;
      }
      if(cell.adjacent === 0){
        floodOpen(r,c);
      }
      if(cellsLeft === mineTotal){
        alert("Поздравляем, вы победили!");
        revealAll();
      }
    }

    function floodOpen(r,c){
      for(let rr=-1; rr<=1; rr++){
        for(let cc=-1; cc<=1; cc++){
          let nr = r+rr;
          let nc = c+cc;
          if(nr>=0 && nr<size && nc>=0 && nc<size){
            let neighbor = board[nr][nc];
            if(!neighbor.open && !neighbor.mine){
              openCell(nr,nc);
            }
          }
        }
      }
    }

    function toggleFlag(r,c){
      let cell = board[r][c];
      if(cell.open) return;
      cell.flag = !cell.flag;
      updateMinesCount();
    }

    function revealAll(){
      for(let r=0; r<size; r++){
        for(let c=0; c<size; c++){
          board[r][c].open = true;
        }
      }
    }

    function updateMinesCount(){
      let flags = 0;
      for(let r=0; r<size; r++){
        for(let c=0; c<size; c++){
          if(board[r][c].flag) flags++;
        }
      }
      let minesLeft = mineTotal - flags;
      minesCountElem.textContent = (minesLeft >= 0) ? minesLeft : 0;
    }

    initBoard();
    drawBoard();
  </script>
</body>
</html>
