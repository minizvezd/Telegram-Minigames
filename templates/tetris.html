<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Тетрис</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0; 
      padding: 0;
      background: #222;
      color: #fff;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    header {
      width: 100%;
      background: #4CAF50;
      color: #fff;
      text-align: center;
      padding: 10px;
      position: relative;
    }
    .back-button {
      position: absolute;
      left: 10px;
      top: 10px;
      text-decoration: none;
      background: #333;
      color: #fff;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 14px;
    }
    .back-button:hover {
      background: #555;
    }
    h1 {
      margin: 0;
      font-size: 20px;
    }
    .instructions {
      margin: 10px;
      font-size: 14px;
      background: #333;
      padding: 6px 10px;
      border-radius: 4px;
      line-height: 1.4;
    }
    #info {
      margin-top: 5px;
      font-size: 16px;
    }
    #tetrisCanvas {
      border: 2px solid #999;
      background: #111;
      margin-top: 10px;
      display: block;
    }
    #gameOver {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      display: none;
    }
    #gameOver button {
      margin-top: 10px;
      padding: 8px 16px;
      background: #f66;
      border: none;
      cursor: pointer;
      color: #fff;
      border-radius: 5px;
      font-size: 16px;
    }
    #gameOver button:hover {
      background: #d55;
    }
    @media(max-width: 600px){
      #tetrisCanvas {
        width: 180px !important;
        height: 360px !important;
      }
    }
  </style>
</head>
<body>
  <header>
    <a class="back-button" href="/">Назад</a>
    <h1>Тетрис</h1>
  </header>

  <div class="instructions">
    Управление: стрелки или WASD. 
    <br>Влево/Вправо — сдвиг, Вверх — поворот, Вниз — ускорение падения.
    <br>На телефоне: свайпы (влево/вправо — сдвиг, вверх — поворот, вниз — ускорение).
  </div>
  
  <div id="info">
    Очки: <span id="score">0</span>
  </div>

  <div style="position: relative;">
    <canvas id="tetrisCanvas" width="200" height="400"></canvas>
    <div id="gameOver">
      <h2 id="finalScore"></h2>
      <button onclick="restartGame()">Играть снова</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("tetrisCanvas");
    const ctx = canvas.getContext("2d");

    const COLS = 10;
    const ROWS = 20;
    const BLOCK_SIZE = 20;

    canvas.width = COLS * BLOCK_SIZE;
    canvas.height = ROWS * BLOCK_SIZE;

    const SHAPES = [
      [[1,1,1],[0,1,0]],  // T
      [[1,1],[1,1]],      // O
      [[1,0,0],[1,1,1]],  // L
      [[0,0,1],[1,1,1]],  // J
      [[0,1,1],[1,1,0]],  // S
      [[1,1,0],[0,1,1]],  // Z
      [[1,1,1,1]]         // I
    ];
    const COLORS = ["cyan","yellow","purple","green","red","blue","orange"];

    let board = [];
    let score = 0;

    let currentPiece = null;
    let currentColor = null;
    let currentX = 0;
    let currentY = 0;

    let dropInterval = 700;
    let dropCounter = 0;
    let lastTime = 0;

    let isGameOver = false;
    let animationFrameId = null;

    // Свайпы
    let touchStartX = 0;
    let touchStartY = 0;
    const SWIPE_THRESHOLD = 30;

    function createMatrix(rows, cols) {
      let matrix = [];
      for (let r=0; r<rows; r++){
        matrix.push(new Array(cols).fill(0));
      }
      return matrix;
    }

    function spawnPiece() {
      const index = Math.floor(Math.random()*SHAPES.length);
      currentPiece = SHAPES[index].map(row => [...row]);
      currentColor = COLORS[index];
      currentY = 0;
      currentX = (COLS/2|0) - (currentPiece[0].length/2|0);

      // Проверяем коллизию сразу
      if (collide(board, currentPiece, currentX, currentY)) {
        // Game Over
        gameOverFunc();
      }
    }

    function collide(board, piece, offX, offY) {
      for(let r=0; r<piece.length; r++){
        for(let c=0; c<piece[r].length; c++){
          if (piece[r][c] !== 0) {
            let nr = offY + r;
            let nc = offX + c;
            if(nr<0 || nr>=ROWS || nc<0 || nc>=COLS || board[nr][nc] !== 0){
              return true;
            }
          }
        }
      }
      return false;
    }

    function merge(board, piece, offX, offY, color) {
      for(let r=0; r<piece.length; r++){
        for(let c=0; c<piece[r].length; c++){
          if(piece[r][c] !== 0) {
            board[offY + r][offX + c] = color;
          }
        }
      }
    }

    function rotate(matrix) {
      const result = [];
      for(let r=0; r<matrix[0].length; r++){
        let row = [];
        for(let c=matrix.length-1; c>=0; c--){
          row.push(matrix[c][r]);
        }
        result.push(row);
      }
      return result;
    }

    function lineClear() {
      let lines = 0;
      for(let r=ROWS-1; r>=0; r--){
        if(board[r].every(cell => cell !== 0)){
          board.splice(r,1);
          board.unshift(new Array(COLS).fill(0));
          lines++;
          r++;
        }
      }
      if(lines > 0){
        score += lines*10; // +10 за линию
      }
    }

    function drop() {
      currentY++;
      if(collide(board, currentPiece, currentX, currentY)){
        currentY--;
        // Фигура «встала» => +1 очко
        score += 1; 
        merge(board, currentPiece, currentX, currentY, currentColor);
        lineClear();
        spawnPiece();
      }
      dropCounter = 0;
      updateScore();
    }

    function updateScore() {
      document.getElementById("score").textContent = score;
    }

    function update(time=0) {
      if(isGameOver) return; 
      const delta = time - lastTime;
      lastTime = time;

      dropCounter += delta;
      if(dropCounter > dropInterval){
        drop();
      }

      draw();
      animationFrameId = requestAnimationFrame(update);
    }

    function draw() {
      ctx.fillStyle = "#111";
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // Рисуем поле
      for(let r=0; r<ROWS; r++){
        for(let c=0; c<COLS; c++){
          let val = board[r][c];
          if(val !== 0){
            drawBlock(c, r, val);
          }
        }
      }

      // Рисуем текущую фигуру
      if(currentPiece){
        for(let r=0; r<currentPiece.length; r++){
          for(let c=0; c<currentPiece[r].length; c++){
            if(currentPiece[r][c] !== 0){
              drawBlock(currentX + c, currentY + r, currentColor);
            }
          }
        }
      }
    }

    function drawBlock(x,y,color) {
      ctx.fillStyle = color;
      ctx.fillRect(x*BLOCK_SIZE, y*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
      ctx.strokeStyle = "#333";
      ctx.strokeRect(x*BLOCK_SIZE, y*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    }

    function gameOverFunc() {
      isGameOver = true;
      cancelAnimationFrame(animationFrameId);
      document.getElementById("finalScore").textContent = `Игра окончена! Ваш счёт: ${score}`;
      document.getElementById("gameOver").style.display = "block";
    }

    function restartGame() {
      // Сбрасываем всё
      board = createMatrix(ROWS, COLS);
      score = 0;
      isGameOver = false;
      dropCounter = 0;
      lastTime = 0;
      document.getElementById("gameOver").style.display = "none";
      updateScore();

      spawnPiece();
      // Снова запускаем цикл
      if(animationFrameId) cancelAnimationFrame(animationFrameId);
      animationFrameId = requestAnimationFrame(update);
    }

    // Управление
    document.addEventListener("keydown", e=>{
      if(isGameOver) return;
      if(e.key==="ArrowLeft"||e.key==="a"||e.key==="A"){
        if(!collide(board, currentPiece, currentX-1, currentY)){
          currentX--;
        }
      } else if(e.key==="ArrowRight"||e.key==="d"||e.key==="D"){
        if(!collide(board, currentPiece, currentX+1, currentY)){
          currentX++;
        }
      } else if(e.key==="ArrowDown"||e.key==="s"||e.key==="S"){
        drop();
      } else if(e.key==="ArrowUp"||e.key==="w"||e.key==="W"){
        let rotated = rotate(currentPiece);
        if(!collide(board, rotated, currentX, currentY)){
          currentPiece = rotated;
        }
      }
    });

    // Свайпы
    canvas.addEventListener("touchstart", e=>{
      let t = e.touches[0];
      touchStartX = t.clientX;
      touchStartY = t.clientY;
    });
    canvas.addEventListener("touchend", e=>{
      if(isGameOver) return;
      let t = e.changedTouches[0];
      let dx = t.clientX - touchStartX;
      let dy = t.clientY - touchStartY;
      if(Math.abs(dx)>Math.abs(dy)){
        if(dx>SWIPE_THRESHOLD){
          // вправо
          if(!collide(board, currentPiece, currentX+1, currentY)){
            currentX++;
          }
        } else if(dx< -SWIPE_THRESHOLD){
          // влево
          if(!collide(board, currentPiece, currentX-1, currentY)){
            currentX--;
          }
        }
      } else {
        if(dy>SWIPE_THRESHOLD){
          // вниз
          drop();
        } else if(dy< -SWIPE_THRESHOLD){
          // вверх (поворот)
          let rotated = rotate(currentPiece);
          if(!collide(board, rotated, currentX, currentY)){
            currentPiece = rotated;
          }
        }
      }
    });

    // Старт
    restartGame();
  </script>
</body>
</html>
